# 概述

****

**语言**

**进制**

**进制如何运算**

**二进制**

**数据宽度**

**有符号和无符号数**

**原码反码补码**

**位运算**

**位于运算计算**

**汇编**

**寄存器**

**内存**

**汇编指令**

**内存复制**

**堆栈的指令**

**汇编如何写函数**

**堆栈传参**

**堆栈平衡**

**外挂**

---

## 1 语言

**什么是机器语言？**

```shell
# 目前主流的电子计算机
状态：0和1
# 最早的程序员：穿孔卡带
加 0100 0000
减 0100 1000
乘 0100 1000 0100 1000
除 0100 1000 1100 1000
```

这些东西怎么简化--->助记符！汇编语言 人能够理解的语言翻译为计算机能理解的语言

```shell
加 INC -编译器-> 0100 0000
减 DEC          0100 1000
乘 MUL |        0100 1000 0100 1000
除 DIV          0100 1000 1100 1000
```

汇编一般用于底层的编写，单片机等

**C语言**

```shell
加 A+B -编译器-> 0100 0000
减 A-B          0100 1000
乘 A*B          0100 1000 0100 1000
除 A/B          0100 1000 1100 1000
```

**进制**

十进制 ：0 1 2 3 4 5 6 7 8 9 10

自定义十进制：0 2 4 6 8 a b c f e 20

应用于加密解密，**进制加密**

**进制运算**

```shell
# 八进制计算下面结果
2+3=5
2*3=6
4+5=11
4*5=24

# 运算的本质就是查数
0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30

# 八进制计算下面结果 进制计算表
277+233 = 
276*54 = 
237-54 = 
234/4 = 
```

**二进制**

计算机使用二进制0和1！ 状态！ 电子！

物理极限：摩尔定律！ 硬操作！

追求语言的极限：并发语言，软操作！

**量子计算机**

可以使用量子计算的机器

传统计算机：集成电路！0，1。硅晶片

量子计算机的单位：昆比特。（量子比特！）量子的两态表示。提高计算机的计算力

光子：正交偏振方向

磁场：电子的自旋方向

21世纪，计算机快到尽头了



**数据宽度**

计算机：内存！给数据增加数据宽度

bit 位: 一位 

Byte 字节: 8位

C和C++ Java都需要定义数据类型，计算机底层需要给这些数据定义宽度



**有符号数和无符号数**

数据都是有宽度的，每个数据代表什么意思呢

规则：二进制解码的规则

无符号数的规则：二进制数是什么就是什么

```shell
1001 1010 十六进制：0x9A 十进制：154
```

有符号数的规则：最高位是符号位：1（负数）0（正数）

```shell
1001 1010 如何装换
```

**原码反码补码**

编码规则：

原码：最高位符号位，对其他的位取本身的绝对值

反码：

- 正数：反码与原码相同
- 负数：符号位一定是1 其余位对原码取反

补码

- 正数：反码与原码相同
- 负数：符号位一定是1     **反码+1**

```shell
# 这些数据以8位计算
# 如果是正数，原码反码补码是一样的
1
# 原码 0 000 0001
# 反码 0 000 0001
# 补码 0 000 0001

-1
# 原码 1 000 0001
# 反码 1 111 1110
# 补码 1 111 1111

-7
# 原码 1 000 0111
# 反码 1 111 1000
# 补码 1 111 1001

3+5 = 8
# 二进制：11 + 101=1000 
```



**寄存器**

```shell
mov 寄存器, 值 #将值存到指定寄存器中
```

寄存器中存储 负数 是存的是**补码**



**位运算**

2*8最高效的计算方式--->位运算

```shell
# 与运算 and &
1011 0001
1101 1000
--------- #与运算
1001 0000

# 或运算 or |
1011 0001
1101 1000
--------- #或运算
1111 1001

# 异或运算 xor ^
1011 0001
1101 1000
--------- #异或运算
0110 1001

# 非运算 not ~
1011 0001
---------
0100 1110
```

通过为运算实现加减乘除

**位运算（移动位）**

```shell
# 左移（shl <<）
0000 0001 #所有二进制位全部左移若干位，高位丢弃，低位补0
<<1
---------
0000 0010

# 右移（shr >>）
0000 0001 #所有二进制位全部左移若干位，低位丢弃，高位补0，1（符号位决定）
>>1
---------
0000 0000
```



**位运算的加减乘除**

```shell
# 4+5? 计算机是怎么操作的
0000 0100
0000 0101
---------#（加法，计算机不会这么加）
0000 1001

# 计算机加法的实现原理
# 第一步异或：不考虑进位
0000 0100
0000 0101
--------- #（xor ^）
0000 0001
# 第二步与运算：判断进位 如果与运算结果为0，则没有进位
0000 0100
0000 0101
--------- #（and &）
0000 0100
# 第三步：将与运算结果左移一位
0000 0100
--------- #（shl <<）
0000 1000
# 第四步：异或
0000 0001
0000 1000
--------- #（xor ^）
0000 1001
# 第五步与运算：判断进位 如果与运算结果为0，则没有进位
0000 0001
0000 1000
--------- #（and &）
0000 0000  #（没有进位，则最后结果为上一个异或运算的结果）

# 4-5? 计算机是怎么操作的
0000 0100
1111 1011 # 取补码  
--------- #（减法，计算机不会这么减）
1111 1111
# 计算机加法的实现原理
# 第一步异或：不考虑进位
0000 0100
1111 1011 # 取补码
--------- #（xor ^）
1111 1111
# 第二步与运算：判断进位 如果与运算结果为0，则没有进位
0000 0100
1111 1011 # 取补码
--------- #（and &）
0000 0000

# 乘：x*y, 就是y个x相加
# 除：x/y，本质就是减法，
```



**汇编语言**

通过汇编指令，给计算机发一些操作，然后让计算机执行。

**通用寄存器**

寄存器：

存储数据：CPU > 内存 > 硬盘

32位CPU  支持   8 16 32 位寄存器

64位CPU  支持   8 16 32 64（增加了新的寄存器，增强了寻址能力） 位寄存器

```shell
# 32位的通用寄存器有8个
EAX ECX EDX EBX ESP EBP ESI EDI
# 存值的范围0~FFFF FFFF
# 对于二进制来说直接修改值

#mov指令
mov EAX, 1 #将数字写入寄存器
mov ECX, EAX #将寄存器中的值写到寄存器

# 不同的寄存器
FFFFFFFF      FFFF        FF
32位          16位        8位
EAX            AX         AL  #L代表低8位
ECX            CX         CL
EDX            DX         DL
EBX            BX         BL
ESP            SP         AH  #H代表高8位
EBP            BP         CH 
ESI            SI         DH
EDI            DI         BH

```



**内存**

****

寄存器很小，不够用，所有数据放到内存。

32位计算机最大寻址空间为4GB 0~FFFF FFFF

内存如何存值？

数据宽度：byte（8） word（16） dword（32） qword（64）

地址的位置：0xFFFF FFFF

不是任意的地址都可以写东西，只有程序申请过的内存能够放值。

```shell
# 汇编如何向内存中写值
# mov 数据宽度（byte word dword qword） 内存地址, 值

mov byte ptr ds:[0x0019FF70],1 
mov dword ptr ds:[0x0019FF74],1 #指定地址写入值

# 传递的值的大小一定要和数据宽度匹配
```

**内存的多种写法**

```shell
ds:[0x0019FF70+4] # 表示ds:[0x0019FF74]
ds:[EAX]
ds:[EAX+4]
# 数组
ds:[reg+reg*{1,2,4,8}]
ds:[reg+reg*{1,2,4,8}+]
```













